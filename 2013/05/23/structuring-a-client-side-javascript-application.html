<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport"
   content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Structuring a client-side JavaScript application - Austin Birch's blog</title>

  <!-- code highlighting -->
  <link rel="stylesheet" type="text/css" href="/stylesheets/highlight.css" />
  <script src="/javascripts/highlight.pack.js"></script>
  <script type="text/javascript">
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
  </script>

  <!-- typekit -->
  <script type="text/javascript" src="//use.typekit.net/lkb2raz.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  <!-- my stuff -->
  <link rel="stylesheet" type="text/css" href="/stylesheets/main.css" />

  <!-- google analytics -->
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37660403-1']);
    _gaq.push(['_trackPageview']);

    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript';ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
  <div id="sticky-wrapper">
    <div id="body-wrapper">
      <div class="container">

        <div class="container">
  <header>
    <nav>
      <ul>
        <li><a href="/">blog</a></li>
        <li><a href="/archive">archive</a></li>
        <li><a href="/about">about</a></li>
        <li><a href="https://twitter.com/austinbirch">twitter</a></li>
        <li><a href="http://madebybottle.co.uk/">madebybottle</a></li>
      </ul>
    </nav>
  </header>
</div>


        <div class="content">
          <div class="post-list">
            <div class="container">
              



 <section class="post">
  <div class="post-header">
    <h1 class="post-title"><a href="/2013/05/23/structuring-a-client-side-javascript-application.html">Structuring a client-side JavaScript application</a></h1>
  </div>

  <div class="post-body">
    
      <div class="excerpt"><p>Deciding how to structure a client-side JavaScript application can be quite a challenge, as there are few popular conventions for doing so.</p>

<p>For the application that I am writing at my current startup, BottleCRM, I have come up with what I think is an interesting approach, considering our particular requirements and restrictions.</p>
</div><!--more--><div class='aside'><p>
I should warn you that this post turned out to be much longer than I
originally anticipated, and it is only a high-level overview of the structure
that I have used to develop BottleCRM.
<br /><br />
I plan on writing more in-depth posts (they will be shorter, more
technical, and include examples) about specifics later.
</p></div>
<h2 id='our_requirements'>Our requirements</h2>

<p>Firstly, I should explain that the BottleCRM application comes with a set of design restrictions that some other client-side JavaScript applications will not have to face, the biggest of which is our plugin system.</p>

<p>BottleCRM will allow the user to write (or select from an app-store sort of arrangement), plugins that will be run on the client. The aim is to enable competent JavaScript programmers to customize the software to closer match their business needs.</p>

<p>This is a bit of a nightmare for designing the fundamental structure, as decisions made now may be hard to change once third-parties (or even myself) write plugins that extend the functionality of the application.</p>

<p>The more plugins there are, the harder it is to change the plugin system. The more complicated the plugin system is, the harder it is to write plugins that interact well with the application and.</p>

<h2 id='modules'>Modules</h2>

<p>Structuring client-side JavaScript applications should be no different than structuring applications written in other languages, but as JavaScript (in the browser), has no real module loading system, amongst some other oddities, this can be a difficult task.</p>

<p>You cannot really start to design a decoupled and flexible application without being able to separate the code into individual units. Because of this, the first thing that is required for application structure is a module system.</p>

<p>The module system I am using is <a href='http://component.io/'>component</a>, which works in a very similar way to <a href='http://nodejs.org/'>Node.js</a> modules. I prefer the CommonJS style module declarations to the <a href='http://requirejs.org/docs/whyamd.html'>AMD</a> style, (both systems have their own set of advantages/disadvantages), and using any module system is much better than using none at all.</p>

<h2 id='options_for_application_structure'>Options for application structure</h2>

<p>There are many different approaches that you can take, and mine is a combination of different methods (especially the mediator and facade patterns) that I have read about and explored with test projects.</p>

<p>A good place to start reading upon the different options would be any of the below:</p>

<ul>
<li><a href='http://addyosmani.com/largescalejavascript/' title='Patterns For Large-Scale JavaScript Application Architecture'>Patterns For Large-Scale JavaScript Application Architecture</a></li>

<li><a href='http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/' title='http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/'>Learning JavaScript Design Patterns</a></li>

<li><a href='http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded' title='My Clojure Workflow, Reloaded'>My Clojure Workflow, Reloaded</a></li>
</ul>

<p>Also, though Backbone specific, <a href='http://addyosmani.com/blog/'>Addy Osmani&#8217;s</a> book, <a href='http://addyosmani.github.io/backbone-fundamentals/'>Developing Backbone.js Applications</a>, has some really great ideas.</p>

<h2 id='my_approach'>My approach</h2>

<p>I do not believe that programming is about forcing your problem into design patterns, so I try to avoid implementing pattern specifics too much, and instead just follow the ideas and concepts of the design patterns that fit the problem more naturally.</p>

<p>It is especially important to think of the problems that are specific in your problem domain, and to think about the best ways in which those problems can be solved &#8212; sometimes you need a little of this pattern, and a bit of another.</p>

<p>For BottleCRM, the biggest problem I have to solve, in regards to application structure, is the plugin system.</p>

<p>Implementing a plugin system, and the ideas in which it represents (the ability for other developers to hook in their own code and customisations), usually involves quite complicated APIs, interfaces and other connecting parts. This can be quite troublesome to maintain, especially when you are just starting out, as plugin developer requirements, and the functionality that plugins should be able to achieve, may change in the future. This is especially true early-on, when ideas are still relatively untested, and direction is not as solid as it will be later on.</p>

<p>In order to remove the complexity that is usually involved in a plugin system, I decided to not really have one. Though this sounds counter-intuitive, for an application that is almost all about plugins, it should become clearer as you read on.</p>

<p>Instead of a plugin API, the core of the application would just be a plugin loader, and nothing else. It knows which plugins to start, and requires them. The plugins themselves do not need to require other plugins, or express their dependency on other plugins in any other way. Instead, all communication goes through an <em>event bus</em>.</p>

<p>This removes the requirement for the plugin loader to do any special kind of dependency resolution, or handle connecting plugins to other plugins, and reduces the complexity of the application quite a bit.</p>

<p>The application event bus is created by the module loader, and passed as a parameter to each plugins constructor. The plugin keeps a reference to this event bus, and using this reference can communicate with other components in the system via; en-queuing and handling messages, listening for and emitting events.</p>

<p>In order to reduce complexity and boilerplate code within a plugin, it only has a small interface that it needs to conform to. This interface outlines that a plugin should have two functions (aside from the constructor): <span class='monospace'>initialize</span> and <span class='monospace'>stop</span>.</p>

<p>Once all plugins have been instantiated, <span class='monospace'>initialize</span> will be called, and <span class='monospace'>stop</span> will be called when a plugin is to be disposed of, allowing it to shut down gracefully.</p>

<h2 id='the_event_bus'>The event bus</h2>

<p>The event bus has a couple of distinct parts, and the way that it is used by the components shapes the application structure.</p>

<p>The parts are:</p>

<ul>
<li>A <em>pub/sub</em> system</li>

<li>A <em>message queue</em></li>
</ul>

<h3 id='pubsub'>Pub/sub</h3>

<p>The traditional <em>publish/subscribe</em> system, where components can <span class='monospace'>subscribe</span> to events (by name), and other components can <span class='monospace'>publish</span> events. The events can have extra data associated with them that describe what happened.</p>

<p>Components that <span class='monospace'>subscribe</span> to events are called <em>consumers</em>, and components that <span class='monospace'>publish</span> events are <em>producers</em>.</p>

<p>In BottleCRM, for the most part, events are used to describe things that have happened, so that multiple consumers can react to a change in application state. An example of this may be to load extra data when a <span class='monospace'>signin:success</span> event is published.</p>

<h3 id='the_message_queue'>The message queue</h3>

<p>components can register to <span class='monospace'>handle</span> messages, and other components can <span class='monospace'>enqueue</span> them. When you enqueue a message, the last component to register a handler for that message name will have its handler called. Messages will often contain other parameters that the handler should use to perform its work.</p>

<p>Handler functions can allow the message to be passed to any previous handler that was registered if it would like to, allowing interception and modification of messages.</p>

<p>A parameter that will often be passed as part of a message will be a callback function. For example, we might enqueue a database call, to find all of users in the system. A callback function would be supplied along with the message for the handler to call with the result.</p>

<p>This sort of messaging is used to expose all of the functionality that a plugin provides to the system. A short list of examples would look like this:</p>

<ul>
<li>View creation</li>

<li>Building models</li>

<li>Saving models</li>

<li>Searching the local cache</li>

<li>Searching the remote database</li>

<li>Navigating to a different local route</li>

<li>Showing a view in a certain region</li>
</ul>

<p>The message queue, with few exceptions, is used to get other components to do work/jobs. These message names are usually phrased as commands. For example, a component may enqueue a <span class='monospace'>navigate:users</span> message to get a router component to cause some navigation to occur. These messages change the state of the application.</p>

<p>One interesting side effect to the message queue system is that it allows plugins to be initialised <em>after</em> messages that it handles have been enqueued. This is because when the handler function is registered with the event bus, the event bus will dispatch messages to that function that already exist on the queue (if the handler function handles those messages).</p>

<h3 id='effects_of_using_this_structure'>Effects of using this structure</h3>

<p>The best thing about this system is that it allows components and plugins to express their dependencies in terms of <em>work</em> rather than <em>workers</em>. To make an example, instead of a plugin knowing that it depends on a <span class='monospace'>router</span> component in order to perform navigation, it expresses that it wants something to do some navigation for it. This expression is displayed via the name of the message enqueued, in this example a <span class='monospace'>ui:navigate</span> message.</p>
<div class='aside'>
<p>
As an aside, I am likely to write a program to create a graph of these
<em>work dependencies</em> that I will run the source code for BottleCRM
through &mdash; it should be quite interesting to see.
</p>
</div>
<p>This is great for decoupling. The components that are able to do the work can just handle the correct messages, and components that want work to be done can just enqueue work to be done. Neither component know implementation detail about the other, just that they are able perform a function, or would like a function to be performed.</p>

<p>In terms of application structure, this allows us to operate with a low level of ceremony. The only stuff required is the plugin interface (the <span class='monospace'>initialize</span> and <span class='monospace'>stop</span> functions), and the handler function itself.</p>

<p>Arguably, one of the disadvantages of this system is that it forces lots of the code structure to be asynchronous. This can lead to code that some think is more complicated to read, but I hope that it does not take too long for developers that are not familiar with the codebase to get used to it.</p>

<p>I have found, however, that this style of code forces you to think about what happens when some work you request is not performed, or takes a long time to complete. For example, when requesting data from a remote database, you may wish to render a view that shows that you are loading some data. This is, mostly, a nice trait that is forced by this no-guarantees approach.</p>

<p>Rather than defining that you cannot run without another plugin being enabled, (expressing a dependency on that plugin), you must handle the case that the work you requested might not be completed. It might be that you just do nothing (roughly the same as if your plugin has refused to load), however you may decide to follow a different course of action.</p>

<h3 id='problems_and_things_yet_to_be_done'>Problems and things yet to be done</h3>

<p>It is not all wonderful, and there are still lots of details that need to be ironed out.</p>

<p>One of these is versions between plugins. Making sure that various plugins are compatible with other plugins with different versions is a hard problem to solve. I do not want to have to implement the sort of dependency system in which plugins depend on particular versions of other plugins, as this would undo all of the simplification that has been achieved.</p>

<p>I would also like to make it easier to determine for plugins to determine whether handlers are registered for particular messages, without allowing too tight coupling between those plugins and handlers.</p>

<p>I also need to develop a way that components can remove messages that they have enqueued, without them having been processed off of the queue. This is because some messages may be irrelevant or incorrect when applied at a later time. For example, if a <span class='monospace'>navigate:users</span> message was enqueued, without a component to handle it, and some time later a component is initialised that does handle that message, it may be inappropriate for it to take any action.</p>

<p>Another feature that I am looking into is a kind of pipeline flow, with multiple participants that do not know of the implementation details of each other &#8212; sort of like a middleware pattern. I am not too sure on this yet, but it is worth some exploration.</p>

<h3 id='open_source_soon'>Open source (soon)</h3>

<p>The framework that I have built to develop the application is based on <a href='backbonejs.org'>Backbone.js</a>, with some small additions in the form of a couple of <span class='monospace'>Backbone.View</span> subclasses, and some subclasses of <span class='monospace'>Backbone.Collection</span> for caching server models, and creating live data views for view classes.</p>

<p>Of course, the biggest addition that makes this framework interesting is the event bus, and there is no reason that that could not be used in a non-Backbone.js project.</p>

<p>As soon as I pull apart some of the application-specific parts from my framework, and tidy up the event bus code, I will be open sourcing it and putting it up on my <a href='https://github.com/austinbirch/'>Github</a> profile.</p>
<!-- footnotes -->
    
  </div>

  <div class="post-footer">
    <p>
      posted on 23 May 2013</a>
    </p>
  </div>
</section>


<div class="post-profile">
  <div class="profile">
  <div class="profile-image">
    <img
      src="http://www.gravatar.com/avatar/de0cdbdce55f514f66d78fa333164533.png"
      alt="me">
  </div>

  <div class="about">
    <p>
    Hi, I am <strong>Austin Birch</strong>, a software developer,
    design enthusiast and entrepreneur.
    </p>

    <p>
    At the moment my focus is client-side &amp; server-side
    JavaScript, though I write Ruby too, and I am currently learning
    functional programming with Clojure.
    </p>

    <p class="hire-me-maybe">
      I am available for work (full-time / part-time position).
    </p>

    <p>
    If you want to get in touch, or just want to talk, you can send me an
    <a href="mailto:mraustinbirch@gmail.com">email</a>, or just say hello on
     <a href="https://twitter.com/austinbirch">twitter</a>. I am also on
     <a href="https://github.com/austinbirch/">GitHub</a>.
    </p>
  </div>
</div>

</div>

            </div>
          </div>
        </div>

        <div id="sticky-push"></div>
        <footer>
  <div class="container">
    <p class="copyright">&copy; 2012 Austin Birch. Powered by 
      <a href="http://jekyllrb.com">jekyll</a>.</p>
  </div>
</footer>

    </div>

  </div> <!-- sticky wrapper -->
</body>
</html>
